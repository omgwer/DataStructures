#include <iostream>
#include <string>
#include "List.h"
#include "Tree.h"

void addElement(List* list, Tree* newTreeElement)
{
	if (list->current == nullptr) {				// если список пустой, пишем в начало списка
		list->current = newTreeElement;
		list->next = nullptr;
		return;
	}

	std::string newName = newTreeElement->name; // для сортировки вставкой нужно пройтись по существующему списку
	bool isFind = false;

	List* varPtr = list;					// указатель на текущий элемент списка, по которому проходит итерация
	List* prevElementPtr = nullptr;		// указатель на предыдущий элемент списка

	while (!isFind) {			
		if (newName <= varPtr->current->name) { // если новое имя меньше чем текущее в списке,
			List *newElement = new List;
			newElement->current = newTreeElement;
			newElement->next = varPtr;
			if (prevElementPtr == nullptr) {	// если нужно вставить первый элемент списка	
				list = newElement;   //ПЕРЕПИСЫВАЕМ начало списка, так как добавляется элемент в начало списка.				
			}
			else {
				prevElementPtr->next = newElement;				
			}	
			isFind = true;
			continue;
		}		
		if (varPtr->next == nullptr) {   // если список кончился, создаем новый элемент и записываем его в конец
			List* newElement = new List;
			newElement->current = newTreeElement;
			newElement->next = nullptr;
			varPtr->next = newElement;
			isFind = true;
			continue;
		}
		prevElementPtr = varPtr;   // записываем предыдущий элемент списка
		varPtr = varPtr->next;	   // двигаемся по списку вправо
	}
}

//bool isEmpty(List* list) {
//	return list->current == nullptr;
//}
//
//Tree* getElement(List *list, std::string elementName)
//{
//	Tree* ListElement = new Tree;
//	return ListElement;
//}

void printList(List* list) {
	List* var = list;
	while (var->next != nullptr) {
		std::string  test = list->current->name;
		std::cout << "name = " << list->current->name << std::endl;
		var = var->next;
 	}
}